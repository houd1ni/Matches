// Generated by CoffeeScript 1.9.2
var calculate_matches,
  slice = [].slice;

calculate_matches = function() {
  var act, add, additional, callback, equal, exp, i, input_string, output_buffer, rct, self, trace, try_;
  input_string = arguments[0], additional = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
  add = additional[0] || true;
  trace = additional[1] || false;
  if (trace) {
    console.log("input was: " + input_string);
  }
  input_string = input_string.split('=');
  equal = +input_string[1];
  exp = input_string[0];
  output_buffer = [];
  act = {
    0: [8],
    1: [7],
    2: [],
    3: [9],
    4: [9],
    5: [6, 9],
    6: [8],
    7: [],
    8: [],
    9: [8],
    '+': [],
    '-': ['+']
  };
  rct = {
    0: [],
    1: [],
    2: [],
    3: [],
    4: [],
    5: [],
    6: [5],
    7: [1],
    8: [0, 6, 9],
    9: [5, 3],
    '+': ['-'],
    '-': []
  };
  self = {
    0: [6, 9],
    1: [],
    2: [3],
    3: [2, 5],
    4: [11],
    5: [3],
    6: [0, 9],
    7: [],
    8: [],
    9: [0, 6],
    '+': [],
    '-': []
  };
  try_ = function(exp, equal) {
    if (trace) {
      console.log("triing: " + (exp.join('')));
    }
    if (eval(exp.join('')) === equal) {
      if (trace) {
        console.log('GOT!');
      }
      if (trace) {
        console.log((exp.join('')) + " = " + equal);
      }
      if (add) {
        if (output_buffer.length) {
          output_buffer.push("\n" + (exp.join('')) + "=" + equal);
        } else {
          output_buffer.push((exp.join('')) + "=" + equal);
        }
      } else {
        output_buffer.push("\n" + (exp.join('')) + "=" + equal);
      }
      return true;
    }
    return false;
  };
  return (function() {
    var char, chari, got_solution, j, k, ki, l, len, len1, len2, ln, m, new_char1, new_char2, ref, ref1, ref2, temp_exp;
    got_solution = false;
    exp = exp.split('');
    ln = exp.length - 1;
    for (k in exp) {
      char = exp[k];
      if (rct[char].length > 0) {
        ref = rct[char];
        for (j = 0, len = ref.length; j < len; j++) {
          new_char1 = ref[j];
          temp_exp = slice.call(exp.slice(0, +k)).concat([new_char1], slice.call(exp.slice(+k + 1, +ln + 1 || 9e9)));
          for (ki in temp_exp) {
            chari = temp_exp[ki];
            if (act[chari]) {
              ref1 = act[chari];
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                new_char2 = ref1[l];
                if (try_(slice.call(temp_exp.slice(0, +ki)).concat([new_char2], slice.call(temp_exp.slice(+ki + 1, +ln + 1 || 9e9))), equal)) {
                  got_solution = true;
                }
              }
            }
          }
        }
      }
      ref2 = self[char];
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        new_char1 = ref2[m];
        if (try_(slice.call(exp.slice(0, +k)).concat([new_char1], slice.call(exp.slice(+k + 1, +ln + 1 || 9e9))), equal)) {
          got_solution = true;
        }
      }
    }
    if (!got_solution) {
      output_buffer.push('0');
    }
    console.log(output_buffer.join(''));
    return callback(output_buffer.join(''));
  })(this);
};
